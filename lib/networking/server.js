import { PublicIdentity } from "../crypto/identity.js";
import { TimeChunkedEventQueue } from "./time-chunked-event-queue.js";
import { channelRecv, channelSend } from "./message.js";


/**
 * @template S, E
 * @typedef {import("./message.js").Message<S, E>} Message<S, E>
 */
/**
 * @template E
 * @typedef {import("./message.js").PeerMessage<E>} PeerMessage<E>
 */

/**
 * @template S, E
 * @typedef {Object} ServerCallbacks
 * @property {function(void): S} getState
 */

/**
 * @template S, E
 * @extends TimeChunkedEventQueue<E>
 */
export class Server{
  /**
   * @memberof Server
   * @param {ServerCallbacks<S, E>} callbacks
   */
  constructor(callbacks, now = performance.now()) {
    const tickPeriodMs = 50;
    this.msgTime = 0;
    this.eventQueue = new TimeChunkedEventQueue({
      simTime: 0,
      tickPeriodMs,
      timeChunkMs: 10,
      now,
    });
    /** @type {{ [key: string]: RTCDataChannel }} */
    this.clients = {};
    this.callbacks = callbacks;
    this.clientId = "host";
    this.tickTimer = setInterval(() => {
      this.onTick();
    }, tickPeriodMs);

    /** @type {PeerMessage<E>} */
    const joinMsg = {
      type: "peerJoined",
      clientId: this.clientId,
      simTime: this.simTime,
    };
    this.eventQueue.pushMsg(joinMsg);
  }

  // used for testing
  stopTickTimer() {
    clearInterval(this.tickTimer);
  }

  onTick() {
    const nextTickTime = this.simTime + this.tickPeriodMs;
    this.eventQueue.processTick(nextTickTime);
    this.broadcast({ type: "tick", simTime: nextTickTime });
  }

  getEvents(time = performance.now()) {
    return this.eventQueue.getEvents(time);
  }

  /**
   * This is use for sending both client events and server events
   *
   * @param {E} peerEvent
   */
  sendEvent(peerEvent) {
    this.sendClientEvent(this.clientId, peerEvent);
  }

  /**
   * @param {string} clientId
   * @param {E} peerEvent
   */
  sendClientEvent(clientId, peerEvent) {
    /** @type {PeerMessage<E>} */
    const msg = {
      type: "peerEvent",
      clientId: clientId,
      simTime: this.simTime,
      peerEvent,
    };
    this.broadcast({
      type: "peerMessage",
      msg,
    });
  }
  /** @param {Message<S, E>} msg */
  broadcast(msg) {
    // TODO note this doesn't send to the message to ourselves!
    const data = JSON.stringify(msg);
    for (let clientId of Object.keys(this.clients)) {
      this.clients[clientId].send(data);
    }
    if (msg.type === "peerMessage") {
      this.eventQueue.pushMsg(msg.msg);
    }
  }
  /** @param {RTCDataChannel} channel */
  async onConnect(channel) {
    const { identity } = await channelRecv(channel, "identity");

    const publicIdentity = await PublicIdentity.fromJSON(identity);

    const { challenge, verify } = publicIdentity.challenge();

    channelSend(channel, { challenge }, "challenge");

    const { signature } = await channelRecv(channel, "signature");

    if (!(await verify(signature))) {
      throw new Error("Signature verification failed");
    }

    // The cool thing about this id is that it's generated by the client
    // but we can also verify that it's unique by checking the signature
    const clientId = await publicIdentity.toName();

    if (this.clients[clientId]) {
      this.onDisconnect(clientId);
    }
    this.clients[clientId] = channel;
    channel.onclose = () => {
      console.log("client disconnected", clientId);
      this.onDisconnect(clientId);
    };
    channel.onerror = (e) => {
      console.error(e);
      this.onDisconnect(clientId);
    };
    channel.onmessage = (e) => {
      // TODO handle parse failure here (and other places)
      const peerEvent = JSON.parse(e.data);
      this.sendClientEvent(clientId, peerEvent);
    };

    let state = this.callbacks.getState();
    channelSend(
      channel,
      {
        clientId,
        simTime: this.simTime,
        tickPeriodMs: this.tickPeriodMs,
        timeChunkMs: this.timeChunkMs,
        state,
      },
      "connected"
    );

    this.broadcast({
      type: "peerMessage",
      msg: {
        type: "peerJoined",
        clientId,
        simTime: this.simTime,
      },
    });
  }

  /** @param {string} clientId */
  onDisconnect(clientId) {
    this.clients[clientId].close();
    delete this.clients[clientId];

    this.broadcast({
      type: "peerMessage",
      msg: {
        type: "peerLeft",
        clientId,
        simTime: this.simTime,
      },
    });
  }
}
