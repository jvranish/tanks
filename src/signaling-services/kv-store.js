/* eslint-disable no-unused-vars */
import { wait } from "./util.js";
import { TimeoutError, KVError } from "./error.js";
// Add other free servers:
// https://github.com/mafintosh/signalhub
// Extend kv signaling API

// TODO:
// Add support for if-match
// Add support for rate limiting
// rename base signaling service to base KV store
// add a per-KV test (or perhaps make it a signaling service factory test?)

/** @template KV */
export class Key {
  /** @param {string} data */
  constructor(data) {
    this.data = data;
    /** @type {KV | null} */
    this.phantom = null;
  }
}

/**
 * It makes a GET request to the given URL, and returns the response if it was
 * successful, or throws an exception if it was not
 *
 * @param {string} url - The URL to fetch.
 * @returns {Promise<Response>} A promise that resolves to a Response object.
 */
export async function simpleGet(url) {
  const response = await fetch(new Request(url));
  // network errors (invalid dns, timeouts, etc...) will result in
  //  thrown exceptions.
  if (response.ok) {
    return response;
  }
  // These might be useful to handle in a custom implementation:
  // 429 Too Many Requests
  // 412 Precondition failed
  console.error(response);
  throw new KVError("GET failed");
}

/**
 * It makes a POST request to the given URL with the given object stringified
 * into the post body
 *
 * @template T
 * @param {string} url - The URL to send the request to.
 * @param {T} body - An object that will be `JSON.stringify`ed into the body the
 *   POST request.
 * @returns {Promise<Response>} The response object.
 */
export const simplePost = async (url, body) => {
  const response = await fetch(
    new Request(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
  );
  // network errors (invalid dns, timeouts, etc...) will result in
  //  thrown exceptions.
  if (response.ok) {
    return response;
  }
  // These might be useful to handle in a custom implementation:
  // 429 Too Many Requests
  // 412 Precondition failed
  console.error(response);
  throw new KVError("POST failed");
};

/**
 * A base class that provides a key-value store, with a way to create new keys,
 * wait for values to be updated, and merge values in the store.
 *
 * @template V The type of the values to be stores and fetched
 */
export class KVStore {
  /** @returns {string} */
  get name() {
    throw new Error(
      "A minimal implementation of KVStore requires name, getValue and setValue to be defined"
    );
  }

  /**
   * Get the value of a key
   *
   * @param {Key<KVStore<V>>} key
   * @returns {Promise<V>}
   */
  async getValue(key) {
    throw new Error(
      "A minimal implementation of KVStore requires name, getValue and setValue to be defined"
    );
  }

  /**
   * Set the value of a key.
   *
   * @param {Key<KVStore<V>>} key - The key to store the value under. Key must
   *   be generated by a call to `newKey`.
   * @param {V} value - The value to be stored. Must be be a plain javascript
   *   object (JSON.stringify/parse needs to work nicely on it)
   * @returns {Promise<void>}
   */
  async setValue(key, value) {
    throw new Error(
      "A minimal implementation of KVStore requires name, getValue and setValue to be defined"
    );
  }

  /**
   * Create a new key. Some services (such as keyvalue.xyz) have to use an API
   * to generate a key, and this is used for them. Other services just generate
   * a random alpha-numeric string.
   *
   * @returns {Promise<Key<KVStore<V>>>}
   */
  async newKey() {
    throw new Error(
      "A minimal implementation of KVStore requires name, getValue and setValue to be defined"
    );
  }

  /**
   * It waits for a new value to be set for a given key, and returns that new value
   *
   * We need to know the original value in order to prevent an update race
   * between a set and a follow up get.
   *
   * If we implemented a "wait for new value" that just did a `getValue`, and
   * then repeatedly called `getValue` until it got a different answer, it would
   * be very hard to prevent a race in the set-and-wait case.
   *
   * @param {Key<KVStore<V>>} key
   * @param {V} oldValue
   * @param {number} [timeout=300] Timeout in seconds. Default is `300`
   * @returns {Promise<V>}
   */
  async waitForNewValue(key, oldValue, timeout = 300) {
    const stringyOldValue = JSON.stringify(oldValue);

    for (let i = 0; i < timeout; i += 1) {
      await wait(1000);
      const newValue = await this.getValue(key);
      if (stringyOldValue !== JSON.stringify(newValue)) {
        return newValue;
      }
    }
    // No update to the value within the timeout period
    throw new TimeoutError(`No new value after ${timeout} seconds`);
  }

  /**
   * Try to merge the valueToMerge with the current value of key, using the
   * function f, and keep trying until the value doesn't change for 1.2 seconds.
   * Throws exception on failure.
   *
   * Without an atomic update, there is no way to be 100% sure this succeeds, so
   * we have to just do our merge, and then wait to see if they get accidentally
   * clobbered by another peer, and if so, try to do our merge again.
   *
   * This needs to converge even if there are multiple peers attempting to add
   * or update keys at the same time. In order for this to work `f` _must_ to be
   * associative commutative, and idempotent. (kinda like a CRDT merge)
   *
   * Or in other words, `f` needs to work in a way such that you always will get
   * the same result for the same merged values no matter which order you merge them in.
   *
   * @template T
   * @param {Key<KVStore<V>>} key - The key to update
   * @param {T} valueToMerge - The value to merge with the existing value.
   * @param {(a: V, b: T) => Promise<V>} f - A function that takes the current
   *   value and the value to merge, and returns the merged value.
   * @returns {Promise<void>}
   */
  async mergeValueWith(key, valueToMerge, f) {
    let timeSinceLastUpdate = 0;
    for (let i = 0; i < 10; i += 1) {
      // Get the current value
      const existingValue = await this.getValue(key);
      const mergedValue = await f(existingValue, valueToMerge);
      if (JSON.stringify(existingValue) !== JSON.stringify(mergedValue)) {
        // If the mergedValue different than what's
        // stored, then update it.
        await this.setValue(key, mergedValue);
        timeSinceLastUpdate = 0;
      }
      if (timeSinceLastUpdate > 1200) {
        // If no values have needed updating for 1.2 seconds
        // then assume we've succeeded
        return;
      }

      // and wait at least 300ms (plus a random component to help avoid ties)
      const waitTime = 300 + 300 * Math.random();
      await wait(waitTime);
      timeSinceLastUpdate += waitTime;
    }
    throw new KVError("mergeValueWith failed to converge");
  }
}
