<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Rotating Rectangle</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    rotating-rectangle {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <!-- <div id="root"></div> -->
  <rotating-rectangle tabindex="0"></rotating-rectangle>
  <!-- <canvas-wrapper></canvas-wrapper> -->

  <script type="module">
    import { parse } from "./lib/hyperlit.js";
    import { h, text, patch } from "./lib/hyperapp-mini.js";
    import { mini } from "./lib/mini.js";

    const html = parse({ h, text });


    export class CanvasWrapper extends HTMLElement {
      constructor() {
        super();
        this.handle = undefined;
      }

      connectedCallback() {
        this.canvas = document.createElement("canvas");
        this.appendChild(this.canvas);
                this.style.display = 'block';
        this.style.width = '100%';
        this.style.height = '100%';
        this.canvas.width = this.clientWidth;
        this.canvas.height = this.clientHeight;


        // this.tabIndex = 0;
        // this.focus();
        // this.resizeObserver = new ResizeObserver((_entries) => {
        //   this.canvas.width = this.clientWidth;
        //   this.canvas.height = this.clientHeight;
        // });
        // this.resizeObserver.observe(this);
        /** @param {number} time */
        // const render = (time) => {
        //   const event = new CustomEvent("frame", {
        //     detail: { time },
        //   });
        //   this.dispatchEvent(event);
        //   this.handle = requestAnimationFrame(render);
        // };
        // this.handle = requestAnimationFrame(render);
      }

      disconnectedCallback() {
        // this.resizeObserver.disconnect();
        // if (this.handle) {
        //   cancelAnimationFrame(this.handle);
        // }
      }
    }

    customElements.define("canvas-wrapper", CanvasWrapper);


    // const dispatch = mini(
    //   {},
    //   main,
    //   document.getElementById("root"),
    //   patch
    // );

    let angle = 0;
    let prevTime = performance.now();

    function onframe() {
      const currentTime = performance.now();
      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");
      // Calculate the time elapsed since the previous frame
      const deltaTime = (currentTime - prevTime) / 1000;

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save the current canvas state
      ctx.save();

      // Translate the canvas to the center of the rectangle
      ctx.translate(canvas.width / 2, canvas.height / 2);

      // Rotate the canvas by the current angle scaled by the elapsed time
      ctx.rotate(angle);

      // Draw the rectangle
      ctx.fillStyle = 'red';
      ctx.fillRect(-50, -50, 100, 100);

      // Restore the canvas state
      ctx.restore();

      // Update the previous time and the rotation angle
      prevTime = currentTime;
      angle += 3 * deltaTime;
      requestAnimationFrame(onframe);
    }

    function main() {
      requestAnimationFrame(onframe);
      return html`<canvas-wrapper id="wrapper"></canvas-wrapper>`;
    }


    class RotatingRectangle extends HTMLElement {
      constructor() {
        super();

        // Create the canvas element and set its width and height
        const canvas = document.createElement('canvas');

        // Add the canvas element to the custom element and set its dimensions
        this.appendChild(canvas);
        canvas.width = this.clientWidth;
        canvas.height = this.clientHeight;
        this.style.display = 'block';
        this.style.width = '100%';
        this.style.height = '100%';
        // this.tabIndex = 0;
        // this.focus();

        // Get the canvas context and set the fill style to red
        const ctx = canvas.getContext('2d');

        // Set the rotation angle to 0 and the previous time to the current time
        let angle = 0;
        let prevTime = performance.now();

        // Define the animation function using requestAnimationFrame
        const animate = (currentTime) => {
          // Calculate the time elapsed since the previous frame
          const deltaTime = (currentTime - prevTime) / 1000;

          // Clear the canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Save the current canvas state
          ctx.save();

          // Translate the canvas to the center of the rectangle
          ctx.translate(canvas.width / 2, canvas.height / 2);

          // Rotate the canvas by the current angle scaled by the elapsed time
          ctx.rotate(angle);

          // Draw the rectangle
          ctx.fillStyle = 'red';
          ctx.fillRect(-50, -50, 100, 100);

          // Restore the canvas state
          ctx.restore();

          // Update the previous time and the rotation angle
          prevTime = currentTime;
          angle += 3 * deltaTime;

          // Request the next frame
          requestAnimationFrame(animate);
        };

        // Start the animation loop
        requestAnimationFrame(animate);
      }
    }

    customElements.define('rotating-rectangle', RotatingRectangle);
  </script>
</body>

</html>